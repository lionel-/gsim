
# Creating gsim containers

The first thing to do is to create a gsim container with the function
`gsim()`. A container holds the simulations of your parameters as well
as any relevant data, and executes operations on these objects. The
first argument to gsim is the object containing simulations of
parameters. This object can be:

* A Stan, Jags, or CODA object.

* Simulations created by `sim` from the ARM package. The simulations
  are saved in the container under the names `beta` and `sigma`.

* Fitted models (lm, glm, polr, lmer). Gsim then uses `arm::sim` to
sample parameters from their estimated sampling distribution. In the
case of `lmer` objects, the advantage of directly supplying the fitted
model instead of ARM simulations is that gsim can work out the fitted
values (in this case they are saved in the container under the name
*fitted*).

The remaining arguments to gsim are objects containing data to be
saved in the storage space of the container. These can be lists,
data.frames and named numeric vectors or arrays. It is important that
each object is named. An unnamed object will linger in the container
in an invisible state.


# Bangladesh Wells example

In this vignette, we'll first work with the Bangladesh Wells dataset
described in
[Gelman and Hill's textbook](http://www.amazon.com/Analysis-Regression-Multilevel-Hierarchical-Models/dp/052168689X).
This dataset can be retrieved using the `fetch_wells_data()` script.
For simplicity, we'll fit a classical logistic model and use a crude
approximation of the posterior distribution of the parameters obtained
through the `sim()` function from the ARM package.

```{r}
library(gsim)
wells_data <- fetch_wells_data()
wells_fit <- glm(switched ~ c_dist100 * c_arsenic, binomial, wells_data)
wells_sims <- gsim(wells_fit, wells_data, n_sims = 200)
```

In the last command, gsim sampled 200 simulations from the estimated
sampling distribution of the parameters, and made the columns of
`wells_data` available inside the container. Once the container is
created, you can check its contents using `print()`, `summary()`, and
`head()`.

```{r}
print(wells_sims)
```


## Posterior Predictive Check

Gsim is most useful to easily create statistical summaries depending
on data and parameters that can be used to check the model. In this
example, we'll check for overdispersion of the residuals. The observed
residual standard deviation is a relevant summary to check this aspect
of the model. Computing this discrepancy measure is an ideal job for
gsim because it depends on both the data and the parameters of the
regression model. But even if the measure depended solely on the data,
gsim can still be useful to sample replicates from the posterior
predictive distribution (ppd) of the data. In this example, we'll need
to:

* Compute the fitted values. In general, fitted values are a
  by-product of the MCMC sampling procedure and will already be
  available along with the simulated parameters. Also, if we supplied
  a glmer model to gsim, it would have been able to retrieve the
  fitted values automatically. Here however, we need to compute them
  manually.

* Compute the observed residual standard deviation.

* Sample replicates from the ppd.

* Compute the residual standard deviation of the replicates.

We now illustrate the verbosity of the classical approach based on
loops before turning to gsim code.


### Using loops

Here is the code needed to compute the ppc quantities with manual
loops over simulations.

```{r}
n_sims <- 200
n_obs <- nrow(wells_data)

arm_sims <- arm::sim(wells_fit, n_sims)
X <- with(wells_data,
  cbind(rep(1, n_obs), c_dist100, c_arsenic, c_dist100 * c_arsenic)
)

fitted <- array(dim = c(n_sims, n_obs))
for (i in 1:n_sims) {
  fitted[i, ] <- inv_logit(X %*% cbind(arm_sims@coef[i, ]))
}

residuals <- sweep(fitted, 2, wells_data$switched, function(a, b) b - a)
residuals_var <- apply(residuals, 1, var)

y_rep <- array(dim = c(n_sims, n_obs))
residuals_rep <- array(dim = c(n_sims, n_obs))
for (i in 1:n_sims) {
  y_rep[i, ] <- rbinom(n_obs, 1, fitted[i, ])
  residuals_rep[i, ] <- y_rep[i, ] - fitted[i, ]
}
residuals_var_rep <- apply(residuals_rep, 1, var)

loop_p <- mean(residuals_var > residuals_var_rep)
```

Looping requires initializing the arrays and subsetting over the
correct dimensions. Sometimes, we can use functionals such as
`apply()` or `sweep()` to avoid looping, but this does not necessarily
clarify the code. The verbosity of the code distracts the analyst from
thinking about his modeling and checking tasks. Gsim aims to provide a
framework for operating on parameters in which the distance between
the code and the math is as small as possible.


### Using gsim

Gsim abstracts all the looping verbiage to let the user focus on the
math. It also provides several helper functions to enhance code
clarity (note that they all work outside gsim containers as well):

* The `intercept()` function constructs an intercept column. It
  examines the arguments of the surrounding function (here, `cbind()`)
  to figure out automatically the length of the vector of 1's.

* The `inv_logit()` function to transform the linear predictor back to
  the scale of the outcome variable.

* The `col_vector()` wrapper to `cbind()` is a clearer semantic signal
  that you want to turn a vector into a column vector (an array of
  size n x 1). `row_vector()` is also available.

* The `rbernoulli()` wrapper to `rbinom()` makes the code a bit
  clearer. The whole dpqr family of functions is provided in gsim.

But the most clarifying feature of gsim is that array instantiation
and looping are handled internally and transparently.

```{r}
out <- wells_sims({
  X <- cbind(intercept(), c_dist100, c_arsenic, c_dist100 * c_arsenic)
  fitted <- inv_logit(X %*% col_vector(beta))
  residuals <- switched - fitted
  residuals_sd <- sd(residuals)

  y_rep <- rbernoulli(3020, fitted)
  residuals_rep <- y_rep - fitted
  residuals_sd_rep <- sd(residuals_rep)

  p <- residuals_sd > residuals_sd_rep

  summarise_sims(p, mean)
})

out
```

Two things are going on in the last statement. First, since it's not
an assignment statement, gsim returns the result (which we assigned to
the variable `out`). Second, it **summarises** the simulations using the
function provided in the second argument to `summarise_sims()`. In
this case we simply took the mean over the simulations.

This operation is thus different from all the others. Each time a
command operating on parameters is issued, it is normally repeated
`n_sims` times (unless some optimisation takes place for specific
kinds of operations). On the other hand, summarise_sims will apply
the summarising function `n` times, over the simulations.

We have taken the posterior mean of the p-values, but we could have
chosen the median or some quantiles. To facilitate this operation,
gsim provides a shortcut by overloading the modulo operator.


```{r}
p <- wells_sims(p %% median)
```


# Working with gsim

## Retrieving results

Each time an intermediate result is created, it is stored in the
storage space of the container and can be reused or retrieved
later. To retrieve a variable or a statement, just make sure that it
is the last statement. Last statements will be returned
invisibly. This means that you can't see the result in the console if
you just call gsim, but you still can assign it to a variable in your
workspace.

If you want to retrieve several variables from your gsim container,
you can use listed outputs. Also, gsim tries to produce outputs that
are easy to work with in a data.frame format. We now review these two
aspects.


### Listed outputs

You can pull out several variables at once by embedding them in a
list. Inside a gsim container, `list()` uses non-standard evaluation
to work out the names of the objects if you didn't specify them
manually.

```{r fig.align="center"}
out <- wells_sims(list(p, y_rep))
names(out)
```

### Tidy outputs

By default, gsim will transform any output with more than one
dimension (i.e., everything except atomics and vectors) into
data.frames. This makes it easy to interoperate with processing
packages designed to work with this kind of data structures: `dplyr`,
`tidyr`, `ggplot2`, `ggvis`, etc.

```{r}
beta <- wells_sims(beta)
class(beta)
head(beta)
```
 
Gsim uses non-standard evaluation to figure out good column
names. When it cannot find an appropriate name, it uses the default
*theta*. It is therefore important to choose appropriate object names
and to avoid returning an operation without having first saved it a
well named object. Here is an example of gsim resorting to a default
name:

```{r}
out <- wells_sims(beta + beta)
names(out)
```

The 'long' data.frame format is well suited for ggplot2. You can pivot
on the variable *beta* to plot the posterior density of each
coefficient in a facet grid.

```{r echo=FALSE}
library("ggplot2")
theme_set(theme_bw())
```
```{r message=FALSE, warning=FALSE, fig.align="center"}
library("ggplot2")
ggplot(beta, aes(value)) +
  geom_histogram() +
  facet_wrap(~ beta, scales = "free")
```

This behavior can be controlled in several ways:

* The transformation can be inhibited by wrapping the return statement
  with `I()`: `wells_sims(I(beta))` returns a matrix. The simulations
  always occupy the first dimension of the arrays returned by gsim.

* If you want gsim to always return arrays, you can set the
  `tidy_ouput` argument to FALSE when you create a container:
  `wells_sims <- gsim(wells_fit, tidy_output = FALSE)`. Then, you can
  selectively transform outputs to data.frames by wrapping the return
  statement with `T()`.

Note that `list()` trims the names from their modifiers.

```{r}
out <- wells_sims(list(I(beta), I(sigma)))
names(out)
```


## Reusable statements

You can quote a statement or a group of statements and save the quote
for later use. To save a single statement, just quote it:

```{r}
X_op <- quote(X <- cbind(intercept(), c_dist100, c_arsenic, c_dist100 * c_arsenic))
```

To save several statements, wrap them in curly braces before quoting
them:

```{r}
sd_check_ops <- quote({
  fitted <- inv_logit(X %*% col_vector(beta))
  residuals <- switched - fitted
  residuals_sd <- sd(residuals)

  y_rep <- rbernoulli(3020, fitted)
  residuals_rep <- y_rep - fitted
  residuals_sd_rep <- sd(residuals_rep)
})
```

You then supply the quotes to a gsim container:
```{r}
wells_sims(X_op, sd_check_ops)
```

This can be useful to perform similar checks on different models. For
example, you could create a second container with a different model
including additional predictors. To perform the same check as before,
only the design matrix *X* needs to be adapted.

A quoted statement can't have a name that is already taken in the
container. When a gsim container gets a name as an argument, it first
checks inside its storage space. And only if it doesn't find an object
with this name will it check for a quoted statement in the calling
environment.


# Reactive functions

## Basics

A nice feature is the ability to easily plot posterior summaries by
creating reactive outputs. To give gsim the signal to create a
reactive output, we specify inputs with `x()`, `y()` and `z()`. These
inputs will become arguments in the reactive function.

```{r}
wells_sims2 <- gsim(wells_fit, wells_data)

fitted_fun <- wells_sims2({
  x <- x()
  X <- cbind(1, x, 2, x * 2)
  inv_logit(X %*% beta)
})
class(fitted_fun)
args(fitted_fun)
```

Here we created a function which takes one argument, *x*. We could
have added other arguments, for example by replacing the second
predictor in the design matrix with `y()`. Each time you call this
function with a new *x*, it recomputes the call stack using the new
input value. Below, we compute the fitted values for a sequence of
length 5 ranging from 0 to 2:

```{r}
sequence <- seq(0, 2, length.out = 5)
fitted_fun(sequence)
```

If we call the function a second time, the fitted sequence will be
different. Indeed, the reactive function randomly chooses one
simulation each time it is called.

```{r}
fitted_fun(sequence)
```

You can choose a specific simulation with the argument `out`. For
example, `fitted_fun(sequence, out = 1)` will always return the same
values, the ones corresponding to the first simulation of parameters.


## Plotting fitted models

You can also compute the fitted values over all simulations instead of
just one, and summarise them with a function of your choosing. But
keep in mind that this is an expensive operation if you have a lot of
simulations and a long input sequence: the reactive function will have
to repeat the computation `n_sims * length(sequence)` times. As an
example, we'll compute the posterior mean of the fitted values. To
this end we provide the summarising function in the `out` argument:

```{r}
fitted_fun(sequence, out = mean)
```

This function can be put to good use to plot the fitted line
repeatedly over different simulations to represent posterior
uncertainty. In the snippet below, we use `replicate()` to call our
reactive function repeatedly. We also draw the posterior mean in red.

```{r fig.align="center"}
ggplot(wells_data, aes(x = c_dist100)) +
  geom_point(aes(y = switched), alpha = 0.2) +
  replicate(50, stat_function(fun = fitted_fun, alpha = 0.5)) +
  stat_function(fun = fitted_fun, args = list(out = mean),
    color = "red", size = 1.2)
```

If you are a base graphics user, you can call
`replicate(curve(fitted_fun, add = TRUE))` to produce the same
spaghetti effect.


# Limitations

* If you copy a gsim container, its contents will not be
  duplicated. For example, after issuing `wells_sims_copy <-
  wells_sims`, the two objects will share the same content. Assigning
  or modifying a variable in *wells\_sims\_copy* will also take effect
  inside *wells\_sims*. To effectively copy a container, use
  `clone()`, as in `wells_sims_copy <- clone(wells_sims)`.

* Currently, flow control statements will not work inside gsim (if,
  for, ...).

* Subsetting parameters with square brackets may work, but has not
  been tested yet.
