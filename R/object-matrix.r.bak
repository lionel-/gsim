
assemble_list <- function(args, pos, vseq) {
  n <- length(args)

  if (n == 2) {
    if (pos == 1)
      c(vseq, args[2])
    else
      c(args[1], vseq)

  } else {
    if (pos == 1)
      c(vseq, args[-1])
    else if (pos == n)
      c(args[-n], vseq)
    else
      c(args[seq(1, pos-1)], vseq, args[seq(pos+1, n)])
  }
}

## Does this matrix to list coercion business makes sense?
## What's the point of cbinding things then? Simpler internals? (hum)
## Don't we loose efficiency?

gsvar_binder <- function(bind_fun, names = FALSE) {

  function(...) {
    ## todo: named arguments
    args <- extract_dots(...)
    fun_name <- deparse(match.call()[[1]])

    ## Handling sequences - variadic case
    ## Only for gsvar atm
    seq_gs_pos <- Position(is.seq_gs, args)
    if (!is.na(seq_gs_pos)) {
      res <- lapply(args[[seq_gs_pos]], function(arg) {
        do.call(fun_name, assemble_list(args, seq_gs_pos, list(arg))) # %>%
          ## gs("gsvar")

        ## Use this instead to prevent coercion to list
        ## set_class("gs", "gsvar", "matrix_gs")
      })

      class(res) <- c("gs", "seq_gs")
      return(res)
    }
    
    ## todo: find out what was the purpose of that:
    ## if (!is.list_gs(args))
    ##   args <- concatenate(args)

    ## ## Use this instead to prevent coercion to list
    ## res <- Reduce(bind_fun, args, NULL) %>%
    ##   gs("gsvar")
    ## set_class("gs", "gsvar", "matrix_gs")

    res <- args %>%
      convert_numeric %>%
      make_list

    if (names) {
      res <-
        vapply(args, get_name, character(1)) %>%
          make_names_unique %>%
          set_names(res, .)
      ## set_names_fun(res, .) # not needed if we coerce to list
    }

    res
  }
}


bind_rows <- function(...) {
  UseMethod("bind_rows")
}

bind_rows.gsvar <- gsvar_binder(rbind, FALSE)
bind_rows.numeric <- bind_rows.gsvar


bind_cols <- function(...) {
  UseMethod("bind_cols")
}

bind_cols.gsvar <- gsvar_binder(cbind, TRUE)
bind_cols.numeric <- bind_cols.gsvar

bind_cols.vseq <- function(...) {
  browser()

  test <- list(...)


  gs
}

bind_cols.gsparam <- function(...) {
  args <- extract_dots(...)
  if (!is.list_gs(args))
    args <- concatenate(args)

  res <- Reduce(cbind, args, NULL)
  class(res) <- c("gsparam", "matrix_gs")
  res
}


as.data.frame.matrix_gs <- function(gs, ...) {
  if (is.gsvar(gs)) {
    as.data.frame.matrix(gs, ...)
  }
}


#' @export
is.matrix_gs <- function(x) inherits(x, "matrix_gs")
